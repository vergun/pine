// Generated by CoffeeScript 1.6.3
(function() {
  var CoverageError, EXTENSIONS, StringStream, abbreviatedPath, coffeeScript, debug, defaultOptions, defaults, endsWith, events, fs, getRelativeFilename, mkdirs, path, pkginfo, startsWith, statFile, stripLeadingDotOrSlash, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  coffeeScript = require('coffee-script');

  events = require('events');

  fs = require('fs');

  util = require('util');

  path = require('path');

  path.sep = path.sep || "/";

  _ref = require('./helpers'), startsWith = _ref.startsWith, endsWith = _ref.endsWith, defaults = _ref.defaults, abbreviatedPath = _ref.abbreviatedPath, mkdirs = _ref.mkdirs, stripLeadingDotOrSlash = _ref.stripLeadingDotOrSlash, statFile = _ref.statFile;

  pkginfo = require('pkginfo')(module, 'version', 'author', 'contributors');

  debug = function() {};

  EXTENSIONS = {
    ".coffee": {
      js_extension: ".js"
    },
    "._coffee": {
      js_extension: "._js"
    }
  };

  CoverageError = (function(_super) {
    __extends(CoverageError, _super);

    function CoverageError(message) {
      this.message = message;
      this.name = "CoverageError";
      Error.call(this);
      Error.captureStackTrace(this, arguments.callee);
    }

    return CoverageError;

  })(Error);

  StringStream = (function() {
    function StringStream() {
      this.data = "";
    }

    StringStream.prototype.write = function(data) {
      return this.data += data;
    };

    return StringStream;

  })();

  defaultOptions = {
    coverageVar: '_$jscoverage',
    exclude: [],
    recursive: true,
    bare: false
  };

  getRelativeFilename = function(basePath, fileName) {
    var relativeFileName;
    relativeFileName = path.resolve(fileName);
    if ((basePath != null) && startsWith(relativeFileName, basePath)) {
      relativeFileName = relativeFileName.slice(basePath.length);
    }
    return relativeFileName;
  };

  exports.register = function(options) {
    var basePath, coverage, excludeFile, initStream, instrumentFile, module, origCoffeeHandler, origStreamineCoffeeHandler, streamline_js;
    coverage = new exports.CoverageInstrumentor(options);
    module = require('module');
    if (options.basePath) {
      basePath = path.resolve(options.basePath);
      if (options.initAll) {
        initStream = new StringStream();
        coverage.instrumentDirectory(options.basePath, null, {
          exclude: options.exclude,
          recursive: true,
          initFileStream: initStream
        });
        eval(initStream.data);
      }
    }
    excludeFile = function(fileName) {
      var excludePath, excluded, relativeFilename, _i, _len, _ref1, _ref2;
      excluded = false;
      if (basePath) {
        relativeFilename = getRelativeFilename(basePath, fileName);
        if (relativeFilename === fileName) {
          excluded = true;
        }
      }
      if (_ref1 = !path.extname(fileName), __indexOf.call(Object.keys(EXTENSIONS), _ref1) >= 0) {
        excluded = true;
      }
      _ref2 = options.exclude || [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        excludePath = _ref2[_i];
        if (startsWith(fileName, excludePath)) {
          excluded = true;
        }
      }
      return excluded;
    };
    instrumentFile = function(fileName) {
      var content, coverageFileName, instrumented;
      content = fs.readFileSync(fileName, 'utf8');
      coverageFileName = getRelativeFilename(basePath, fileName);
      instrumented = coverage.instrumentCoffee(coverageFileName, content, options);
      return instrumented.init + instrumented.js;
    };
    origCoffeeHandler = require.extensions[".coffee"];
    require.extensions[".coffee"] = function(module, fileName) {
      if (excludeFile(fileName)) {
        return origCoffeeHandler.call(this, module, fileName);
      }
      return module._compile(instrumentFile(fileName), fileName);
    };
    if (options.streamlinejs) {
      streamline_js = require.extensions["._js"];
      if (streamline_js) {
        origStreamineCoffeeHandler = require.extensions["._coffee"];
        return require.extensions["._coffee"] = function(module, fileName) {
          var compiled;
          if (excludeFile(fileName)) {
            return origStreamineCoffeeHandler.call(this, module, fileName);
          }
          compiled = instrumentFile(fileName);
          return streamline_js(module, fileName, compiled, null);
        };
      }
    }
  };

  exports.CoverageInstrumentor = (function(_super) {
    var fileToLines, fixLocationData, generateUniqueName, nodeType, toQuotedString, validateSrcDest, writeToFile;

    __extends(CoverageInstrumentor, _super);

    function CoverageInstrumentor(options) {
      if (options == null) {
        options = {};
      }
      this.options = defaults(options, defaultOptions);
    }

    toQuotedString = function(string) {
      var answer;
      answer = string.replace(/\\/g, '\\\\');
      return '"' + (answer.replace(/"/g, '\\\"')) + '"';
    };

    fileToLines = function(fileData) {
      var dataWithFixedLfs;
      dataWithFixedLfs = fileData.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      return dataWithFixedLfs.split("\n");
    };

    nodeType = function(node) {
      var _ref1;
      return (node != null ? (_ref1 = node.constructor) != null ? _ref1.name : void 0 : void 0) || null;
    };

    writeToFile = function(outFile, content) {
      return fs.writeFileSync(outFile, content);
    };

    validateSrcDest = function(source, out) {
      var outStat, sourceStat;
      sourceStat = statFile(source);
      outStat = out ? statFile(out) : null;
      if (!sourceStat) {
        throw new CoverageError("Source file " + source + " does not exist.");
      }
      if (outStat) {
        if (sourceStat.isFile() && outStat.isDirectory()) {
          throw new CoverageError("Refusing to overwrite directory " + out + " with file.");
        }
        if (sourceStat.isDirectory() && outStat.isFile()) {
          throw new CoverageError("Refusing to overwrite file " + out + " with directory.");
        }
      }
    };

    generateUniqueName = function(usedNames, desiredName) {
      var answer, suffix;
      answer = "";
      suffix = 1;
      while (true) {
        answer = desiredName + " (" + suffix + ")";
        if (!(__indexOf.call(usedNames, answer) >= 0)) {
          break;
        }
        suffix++;
      }
      return answer;
    };

    CoverageInstrumentor.prototype.instrument = function(source, out, options) {
      var sourceStat;
      validateSrcDest(source, out);
      sourceStat = statFile(source);
      if (sourceStat.isFile()) {
        return this.instrumentFile(source, out, options);
      } else if (sourceStat.isDirectory()) {
        return this.instrumentDirectory(source, out, options);
      } else {
        throw new CoverageError("Can't instrument " + source + ".");
      }
    };

    CoverageInstrumentor.prototype.getOutputFileName = function(fileName) {
      var coffee_extension, ext, outFile;
      if (fileName == null) {
        return null;
      }
      outFile = fileName;
      for (coffee_extension in EXTENSIONS) {
        ext = EXTENSIONS[coffee_extension];
        if (endsWith(fileName.toLowerCase(), coffee_extension)) {
          outFile = fileName.slice(0, +(-(coffee_extension.length + 1)) + 1 || 9e9) + ext.js_extension;
          break;
        }
      }
      return outFile;
    };

    CoverageInstrumentor.prototype.instrumentDirectory = function(sourceDirectory, outDirectory, options) {
      var answer, coffee_extension, exclude, file, inst, instrumentOptions, outDirectoryStat, outFile, outputDirectoryExists, processed, relativePath, skip, sourceDirectoryMode, sourceFile, sourceStat, _i, _j, _len, _len1, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      sourceDirectory = path.resolve(sourceDirectory);
      this.emit("instrumentingDirectory", sourceDirectory, outDirectory);
      options = Object.create(options);
      options.usedFileNames = options.usedFileNames || [];
      options.basePath = options.basePath ? path.resolve(options.basePath) : sourceDirectory;
      answer = {
        lines: 0
      };
      options = defaults(options, this.options);
      validateSrcDest(sourceDirectory, outDirectory);
      if (!endsWith(sourceDirectory, path.sep)) {
        sourceDirectory += path.sep;
      }
      sourceDirectoryMode = (statFile(sourceDirectory)).mode;
      if (outDirectory) {
        if (!endsWith(outDirectory, path.sep)) {
          outDirectory += path.sep;
        }
        outDirectoryStat = statFile(outDirectory);
        outputDirectoryExists = !!outDirectoryStat;
      }
      _ref1 = fs.readdirSync(sourceDirectory);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        file = _ref1[_i];
        skip = false;
        if (__indexOf.call(options.exclude, file) >= 0) {
          skip = true;
        }
        sourceFile = sourceDirectory + file;
        relativePath = getRelativeFilename(options.basePath, sourceFile);
        if (relativePath !== sourceFile) {
          _ref2 = options.exclude;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            exclude = _ref2[_j];
            if (startsWith(relativePath, exclude)) {
              skip = true;
            }
          }
        }
        if (skip) {
          this.emit("skip", sourceDirectory + file);
          continue;
        }
        outFile = outDirectory ? outDirectory + file : null;
        sourceStat = statFile(sourceFile);
        if (options.recursive && sourceStat.isDirectory()) {
          inst = this.instrumentDirectory(sourceFile, outFile, options);
          answer.lines += inst.lines;
        } else {
          processed = false;
          for (coffee_extension in EXTENSIONS) {
            if (coffee_extension === '._coffee') {
              continue;
            }
            if (endsWith(file.toLowerCase(), coffee_extension) && sourceStat.isFile()) {
              if ((outDirectory != null) && !outputDirectoryExists) {
                mkdirs(outDirectory, sourceDirectoryMode);
                outputDirectoryExists = true;
              }
              outFile = this.getOutputFileName(outFile);
              instrumentOptions = Object.create(options);
              instrumentOptions.fileName = relativePath;
              inst = this.instrumentFile(sourceFile, outFile, instrumentOptions);
              answer.lines += inst.lines;
              processed = true;
              break;
            }
          }
        }
      }
      return answer;
    };

    CoverageInstrumentor.prototype.instrumentFile = function(sourceFile, outFile, options) {
      var answer, data;
      if (outFile == null) {
        outFile = null;
      }
      if (options == null) {
        options = {};
      }
      this.emit("instrumentingFile", sourceFile, outFile);
      validateSrcDest(sourceFile, outFile);
      data = fs.readFileSync(sourceFile, 'utf8');
      answer = this.instrumentCoffee(options.fileName || sourceFile, data, options);
      if (outFile) {
        writeToFile(outFile, answer.init + answer.js);
      }
      return answer;
    };

    fixLocationData = function(instrumentedLine, line) {
      var doIt;
      doIt = function(node) {
        return node.locationData = {
          first_line: line - 1,
          first_column: 0,
          last_line: line - 1,
          last_column: 0
        };
      };
      doIt(instrumentedLine);
      return instrumentedLine.eachChild(doIt);
    };

    CoverageInstrumentor.prototype.instrumentCoffee = function(fileName, fileData, options) {
      var answer, ast, err, fileToInstrumentLines, index, init, instrumentTree, instrumentedLines, js, line, lineNumber, origFileName, quotedFileName, _i, _j, _len, _len1, _ref1,
        _this = this;
      if (options == null) {
        options = {};
      }
      origFileName = fileName;
      switch (options.path) {
        case 'relative':
          fileName = stripLeadingDotOrSlash(fileName);
          break;
        case 'abbr':
          fileName = abbreviatedPath(stripLeadingDotOrSlash(fileName));
          break;
        default:
          fileName = path.basename(fileName);
      }
      if (options.usedfileNames) {
        if (__indexOf.call(options.usedfileNames, fileName) >= 0) {
          fileName = generateUniqueName(options.usedfileNames, fileName);
        }
        options.usedfileNames.push(fileName);
      }
      quotedFileName = toQuotedString(fileName);
      try {
        ast = coffeeScript.nodes(fileData);
      } catch (_error) {
        err = _error;
        throw new CoverageError("Could not parse " + fileName + ": " + err.stack);
      }
      instrumentedLines = [];
      instrumentTree = function(node, parent, depth) {
        var childIndex, children, doAnnotation, expression, instrumentedLine, line, _results;
        if (parent == null) {
          parent = null;
        }
        if (depth == null) {
          depth = 0;
        }
        debug("Examining  l:" + (node.locationData.first_line + 1) + " d:" + depth + " " + (nodeType(node)));
        if ((nodeType(node) !== "Block") || node.coffeeCoverageDoNotInstrument) {
          if (nodeType(node) === "If" && node.isChain) {
            debug("  Disabling chaining for if statement");
            node.isChain = false;
          }
          return node.eachChild(function(child) {
            return instrumentTree(child, node, depth + 1);
          });
        } else {
          children = node.expressions;
          childIndex = 0;
          _results = [];
          while (childIndex < children.length) {
            expression = children[childIndex];
            line = expression.locationData.first_line + 1;
            doAnnotation = true;
            if (nodeType(expression) === "Comment") {
              doAnnotation = false;
            }
            if (__indexOf.call(instrumentedLines, line) >= 0) {
              debug("Skipping   l:" + line + " d:" + (depth + 1) + " " + (nodeType(expression)));
              doAnnotation = false;
            }
            if (doAnnotation) {
              debug("Annotating l:" + line + " d:" + (depth + 1) + " " + (nodeType(expression)));
              instrumentedLines.push(line);
              instrumentedLine = coffeeScript.nodes("" + _this.options.coverageVar + "[" + quotedFileName + "][" + line + "]++");
              fixLocationData(instrumentedLine, line);
              children.splice(childIndex, 0, instrumentedLine);
              childIndex++;
            }
            instrumentTree(expression, node, depth + 1);
            _results.push(childIndex++);
          }
          return _results;
        }
      };
      instrumentTree(ast);
      init = "if (typeof " + this.options.coverageVar + " === 'undefined') " + this.options.coverageVar + " = {};\nif ((typeof global !== 'undefined') && (typeof global." + this.options.coverageVar + " === 'undefined')) {\n    global." + this.options.coverageVar + " = " + this.options.coverageVar + "\n} else if ((typeof window !== 'undefined') && (typeof window." + this.options.coverageVar + " === 'undefined')) {\n    window." + this.options.coverageVar + " = " + this.options.coverageVar + "\n}\nif (! " + this.options.coverageVar + "[" + quotedFileName + "]) {\n    " + this.options.coverageVar + "[" + quotedFileName + "] = [];\n";
      for (_i = 0, _len = instrumentedLines.length; _i < _len; _i++) {
        lineNumber = instrumentedLines[_i];
        init += "    " + this.options.coverageVar + "[" + quotedFileName + "][" + lineNumber + "] = 0;\n";
      }
      init += "}\n\n";
      init += "" + this.options.coverageVar + "[" + quotedFileName + "].source = [";
      fileToInstrumentLines = fileToLines(fileData);
      for (index = _j = 0, _len1 = fileToInstrumentLines.length; _j < _len1; index = ++_j) {
        line = fileToInstrumentLines[index];
        if (!!index) {
          init += ", ";
        }
        init += toQuotedString(line);
      }
      init += "];\n\n";
      try {
        js = ast.compile({
          bare: options.bare
        });
      } catch (_error) {
        err = _error;
        throw new CoverageError("Could not compile " + fileName + " after annotating: " + err.stack);
      }
      if ((_ref1 = options.initFileStream) != null) {
        _ref1.write(init);
      }
      answer = {
        init: init,
        js: js,
        lines: instrumentedLines.length
      };
      return answer;
    };

    return CoverageInstrumentor;

  })(events.EventEmitter);

}).call(this);
